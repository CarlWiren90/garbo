datasource db {
  provider = "sqlite"
  url      = "file:./db.db"
}

generator zod {
  provider = "prisma-zod-generator"
}

generator client {
  provider = "prisma-client-js"
}

model Company {
  /// wikidataId is our unique identifier to link to companies, also used to export to or import from wikidata
  wikidataId  String  @id
  name        String
  description String?
  /// Company website URL
  url         String?

  /// TODO: Save Swedish org number, which might be the same as LEI or ISIN
  // swedishOrgNumber

  // TODO: save country and city/region for each company

  // IDEA: tags: make it possible to categorise the data - e.g. "MVP", "batch 1" to enable further comparisons

  industry         Industry?
  reportingPeriods ReportingPeriod[]
  goals            Goal[]
  initiatives      Initiative[]
  baseYears        BaseYear[]

  /// A comment only visible for reviewers to help them work with the company data and remember important info about this company.
  internalComment String?
}

// TODO: Handle broken reporting periods which start in one year and end the next year.
// Maybe reference reporting periods directly in order to only store the dates in one place.

// TODO: question for Alex: Can we assume that base years always are the first year with reported emissions?
// E.g. if they started reporting in 2020, would that be the base year? Or can they say 2015 as base year, without knowing anything about their emissions from that year?

// TODO: Improve structure of base years to handle the case where we have the same value for all scopes.
// The simple solution is to always store three BaseYears, even if they have the same value. This adds more data, to be processed and transferred, but will be simpler to understand and work with.
model BaseYear {
  id         Int    @id @default(autoincrement())
  // IDEA: maybe the year here should be in relation to a specific reporting period, since we need to account for special cases where reporting periods are not just one year
  year       Int
  scope      Int // 1-3
  companyId  String
  metadataId Int

  metadata Metadata @relation(fields: [metadataId], references: [id])
  company  Company  @relation(fields: [companyId], references: [wikidataId])
}

/// Connecting a company to a specific industry and metadata
/// This also gives us the flexibility to add more ways to keep track of which industry a company belongs to.
model Industry {
  id                  Int    @id @default(autoincrement())
  gicsSubIndustryCode String
  metadataId          Int
  companyWikidataId   String @unique

  company      Company      @relation(fields: [companyWikidataId], references: [wikidataId])
  metadata     Metadata     @relation(fields: [metadataId], references: [id])
  industryGics IndustryGics @relation(fields: [gicsSubIndustryCode], references: [subIndustryCode])
}

/// A table containing the standardised GICS codes for categorizing companies into various industries.
model IndustryGics {
  sectorCode      String
  groupCode       String
  industryCode    String
  subIndustryCode String @id

  industries Industry[]
}

/// A reporting period is a timespan for accounting emissions as well as financial data
model ReportingPeriod {
  id        Int      @id @default(autoincrement())
  startDate DateTime
  endDate   DateTime

  companyId   String
  emissionsId Int?   @unique
  economyId   Int?   @unique
  metadataId  Int

  initiatives Initiative[]
  goals       Goal[]
  metadata    Metadata     @relation(fields: [metadataId], references: [id])
  economy     Economy?     @relation(fields: [economyId], references: [id])
  emissions   Emissions?   @relation(fields: [emissionsId], references: [id])
  company     Company      @relation(fields: [companyId], references: [wikidataId])
}

/// Reported emissions for a specific reporting period
model Emissions {
  id                     Int  @id @default(autoincrement())
  // NOTE: If we remove the @unique requirement here, we could perhaps add more scope1 values for the same ReportingPeriod, but only show one at a time
  // This might help us if we want to keep one scope1 extracted by garbo, one estimated by exiobase and one manually entered. However, this would get complicated.
  scope1Id               Int  @unique
  scope2Id               Int  @unique
  scope3Id               Int  @unique
  biogenicEmissionsId    Int? @unique
  scope1And2Id           Int? @unique
  statedTotalEmissionsId Int? @unique

  statedTotalEmissions StatedTotalEmissions? @relation(fields: [statedTotalEmissionsId], references: [id])
  scope1And2           Scope1And2?           @relation(fields: [scope1And2Id], references: [id])
  biogenicEmissions    BiogenicEmissions?    @relation(fields: [biogenicEmissionsId], references: [id])
  reportingPeriod      ReportingPeriod?
  scope1               Scope1                @relation(fields: [scope1Id], references: [id])
  scope2               Scope2                @relation(fields: [scope2Id], references: [id])
  scope3               Scope3                @relation(fields: [scope3Id], references: [id])
}

/// This is used when companies only report a total number for either overall- or scope 3 emissions.
model StatedTotalEmissions {
  id         Int   @id @default(autoincrement())
  total      Float
  unitId     Int
  metadataId Int
  scope3Id   Int?  @unique

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
  scope3    Scope3?      @relation(fields: [scope3Id], references: [id])
}

/// This is used when companies have bad reporting where they have combined scope 1+2 as one value
model Scope1And2 {
  id         Int   @id @default(autoincrement())
  total      Float
  metadataId Int
  unitId     Int

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
}

/// Biogenic emissions are reported separately from scope 1-3
/// If we want to save a more detailed breakdown (when companies reported this), we can use the metadata comment to save this context
model BiogenicEmissions {
  id         Int    @id @default(autoincrement())
  /// Sometimes companies break it down into scope 1-3 - however these should always be stored as a total number according to the GHG protocol.
  total      Float?
  metadataId Int
  unitId     Int

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
}

model Scope1 {
  id         Int    @id @default(autoincrement())
  total      Float?
  metadataId Int
  unitId     Int

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
}

/// For scope 2 emissions, we choose either market-based, location-based or unknown (if the company didn't specify if mb or lb)
/// We generally prefer using market-based emissions, but if that doesn't exist we could use location-based ones, and finally unknown.
model Scope2 {
  id         Int    @id @default(autoincrement())
  /// Market-based emissions
  mb         Float?
  /// Location-based emissions
  lb         Float?
  /// Unknown scope 2 emissions could be either market-based or location-based
  unknown    Float?
  metadataId Int
  unitId     Int

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
}

// TODO: We need to separate scope3 into separate categories, because we need metadata for each scope 3 category value.

/// Scope 3 emissions according to the GHG protocol.
model Scope3 {
  id Int @id @default(autoincrement())

  /// Sometimes, companies only report a total value for scope 3 emissions without disclosing the scope 3 categories.
  /// Other times, they might report both, but their stated total scope 3 emissions might be different than the actual sum of their scope 3 categories.
  /// To get around this, we separate statedTotalEmissions from the actual mathematical total that we summarize during runtime.
  statedTotalEmissionsId Int?                  @unique
  statedTotalEmissions   StatedTotalEmissions?

  // Scope 3 categories
  c1_purchasedGoods                          Float?
  c2_capitalGoods                            Float?
  c3_fuelAndEnergyRelatedActivities          Float?
  c4_upstreamTransportationAndDistribution   Float?
  c5_wasteGeneratedInOperations              Float?
  c6_businessTravel                          Float?
  c7_employeeCommuting                       Float?
  c8_upstreamLeasedAssets                    Float?
  c9_downstreamTransportationAndDistribution Float?
  c10_processingOfSoldProducts               Float?
  c11_useOfSoldProducts                      Float?
  c12_endOfLifeTreatmentOfSoldProducts       Float?
  c13_downstreamLeasedAssets                 Float?
  c14_franchises                             Float?
  c15_investments                            Float?
  /// "Other" is not included in the GHG protocol, but we use it to handle companies who invent their own scope 3 "categories".
  other                                      Float?

  metadataId Int
  unitId     Int

  unit      EmissionUnit @relation(fields: [unitId], references: [id])
  emissions Emissions?
  metadata  Metadata     @relation(fields: [metadataId], references: [id])
}

model Economy {
  id            Int     @id @default(autoincrement())
  // TODO: Consider splitting Economy into separate datapoints, where each one of them has their own metadata.
  // This will make it easier to separate partially verified data
  // TODO: Store turnover with another datatype to prevent rounding errors, never store it as float
  turnover      Float?
  currencyId    Int?
  /// Number of employees (using various methods)
  employees     Float?
  /// The unit defining the number of employees
  employeesUnit String?
  metadataId    Int

  currency        Currency?        @relation(fields: [currencyId], references: [id])
  reportingPeriod ReportingPeriod?
  metadata        Metadata         @relation(fields: [metadataId], references: [id])
}

model Goal {
  id                Int     @id @default(autoincrement())
  description       String
  year              String?
  target            Float?
  // TODO: Maybe reference ReportingPeriod instead
  // However, baseYears for goals might be different than other reporting periods for the company.
  // Thus, we in some cases need to reference something else than the reporting periods
  // For now, let's store them as strings, but in the future maybe use another representation.
  baseYear          String?
  metadataId        Int
  companyId         String
  reportingPeriodId Int?

  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  company         Company          @relation(fields: [companyId], references: [wikidataId])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

model Initiative {
  id                Int     @id @default(autoincrement())
  title             String
  description       String?
  year              String?
  scope             String?
  companyId         String
  metadataId        Int
  reportingPeriodId Int?

  company         Company          @relation(fields: [companyId], references: [wikidataId])
  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

/// Every datapoint has associated metadata about who changed it, when, and using what source
model Metadata {
  id         Int      @id @default(autoincrement())
  /// The comment is used to add relevant information about why the datapoint looks like it does
  comment    String?
  updatedAt  DateTime @default(now()) @updatedAt
  /// The userId who last updated the associated datapoint
  updaterId  Int
  /// The userId who verified the associated datapoint.
  /// Should only be set after human verification, and null if it has not been verified.
  /// Verified datapoints should not be automatically updated by AI extracted or estimatated data, but always go through manual review going forward.
  verifierId Int?

  sources              Source[]
  goal                 Goal[]
  initiative           Initiative[]
  economy              Economy[]
  scope1               Scope1[]
  scope2               Scope2[]
  scope3               Scope3[]
  reportingPeriod      ReportingPeriod[]
  baseYear             BaseYear[]
  biogenicEmissions    BiogenicEmissions[]
  scope1And2           Scope1And2[]
  statedTotalEmissions StatedTotalEmissions[]
  dataOrigin           DataOrigin?
  updater              User                   @relation("metadata_updater", fields: [updaterId], references: [id])
  verifier             User?                  @relation("metadata_verifier", fields: [verifierId], references: [id])
  Industry             Industry[]
}

/// Where the data originated from, e.g. manual entry, AI extraction or estimated with a tool like Exiobase.
model DataOrigin {
  id         Int    @id @default(autoincrement())
  name       String
  metadataId Int    @unique

  metadata Metadata @relation(fields: [metadataId], references: [id])
}

/// Sources define where a datapoint comes from, and can be re-used for
/// multiple datapoints, for example linking the same report
/// which allows updating the report URL in one place if it changes.
model Source {
  id      Int     @id @default(autoincrement())
  url     String?
  /// The comment can be used to specify another source than a report URL
  comment String?

  // The same source can be used for metadata about multiple datapoints
  metadata Metadata[]
}

/// A unit for measuring emissions, e.g. "tCO2e"
model EmissionUnit {
  id                   Int                    @id @default(autoincrement())
  name                 String                 @unique
  StatedTotalEmissions StatedTotalEmissions[]
  Scope1And2           Scope1And2[]
  BiogenicEmissions    BiogenicEmissions[]
  Scope1               Scope1[]
  Scope2               Scope2[]
  Scope3               Scope3[]
}

model Currency {
  id      Int       @id @default(autoincrement())
  name    String    @unique
  economy Economy[]
}

model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  name  String

  // TODO: connect with github ID
  // TODO: store github profile image - or get it via API
  updater  Metadata[] @relation("metadata_updater")
  verifier Metadata[] @relation("metadata_verifier")
}
