datasource db {
  provider = "sqlite"
  url      = "file:./db.db"
}

generator zod {
  provider = "prisma-zod-generator"
}

generator client {
  provider = "prisma-client-js"
}

model Company {
  /// wikidataId is our unique identifier to link to companies, also used to export to or import from wikidata
  wikidataId       String  @id
  name             String  @unique
  description      String?
  /// Company website URL
  url              String?
  industryGicsCode String?

  /// TODO: Save Swedish org number, which might be the same as LEI or ISIN
  // swedishOrgNumber

  // TODO: save country and city/region for each company

  industryGics     IndustryGics?     @relation(fields: [industryGicsCode], references: [subIndustryCode])
  reportingPeriods ReportingPeriod[]
  goals            Goal[]
  initiatives      Initiative[]
  baseYears        BaseYear[]
}

// TODO: Maybe remove the BaseYear table, and instead keep references to specific base years directly on the company
// for example: baseYearScope1/2/3
// Then we could make use of the startDate and endDate, and align it with reporting periods
model BaseYear {
  id         Int    @id @default(autoincrement())
  // IDEA: maybe the year here should be in relation to a specific reporting period, since we need to account for special cases where reporting periods are not just one year
  year       Int
  scope      Int // 1-3
  companyId  String
  metadataId Int

  metadata Metadata @relation(fields: [metadataId], references: [id])
  company  Company  @relation(fields: [companyId], references: [wikidataId])
}

/// A table containing the standardised GICS codes for categorizing companies into various industries.
/// TODO: How to handle multilingual names and descriptions?
/// IDEA: Maybe move the name and description fields into the i18n files instead to be able to maintain standardized translations?
model IndustryGics {
  sectorCode             String
  sectorName             String
  groupCode              String
  groupName              String
  industryCode           String
  industryName           String
  subIndustryCode        String @id
  subIndustryName        String
  subIndustryDescription String

  companies Company[]
}

/// A reporting period is a timespan for accounting emissions as well as financial data
model ReportingPeriod {
  id        Int      @id @default(autoincrement())
  startDate DateTime
  endDate   DateTime

  companyId   String
  emissionsId Int
  metadataId  Int

  initiatives Initiative[]
  goals       Goal[]
  metadata    Metadata     @relation(fields: [metadataId], references: [id])
  economy     Economy?
  emissions   Emissions?
  company     Company      @relation(fields: [companyId], references: [wikidataId])
}

/// Reported emissions for a specific reporting period
model Emissions {
  id                Int @id @default(autoincrement())
  reportingPeriodId Int @unique
  scope1Id          Int
  scope2Id          Int
  scope3Id          Int

  reportingPeriod ReportingPeriod @relation(fields: [reportingPeriodId], references: [id])
  scope1          Scope1[]
  scope2          Scope2[]
  scope3          Scope3[]
}

model Scope1 {
  id          Int    @id @default(autoincrement())
  value       Float?
  biogenic    Float?
  unit        String
  metadataId  Int
  emissionsId Int

  emissions Emissions @relation(fields: [emissionsId], references: [id])
  metadata  Metadata  @relation(fields: [metadataId], references: [id])
}

model Scope2 {
  id          Int    @id @default(autoincrement())
  // TODO: How does scope 2 value (total) compare to the market based vs location based emissions?
  value       Float?
  biogenic    Float?
  unit        String
  /// Market-based emissions
  mb          Float?
  /// Location-based emissions
  lb          Float?
  metadataId  Int
  emissionsId Int    @unique

  emissions Emissions @relation(fields: [emissionsId], references: [id])
  metadata  Metadata  @relation(fields: [metadataId], references: [id])
}

model Scope3 {
  id       Int    @id @default(autoincrement())
  /// We sometimes need to store the total value for scope 3 emissions because some companies only report a total number,
  /// and don't disclose the emissions per scope 3 category.
  value    Float?
  biogenic Float?
  unit     String

  // Scope 3 categories
  c1_purchasedGoods                          Float?
  c2_capitalGoods                            Float?
  c3_fuelAndEnergyRelatedActivities          Float?
  c4_upstreamTransportationAndDistribution   Float?
  c5_wasteGeneratedInOperations              Float?
  c6_businessTravel                          Float?
  c7_employeeCommuting                       Float?
  c8_upstreamLeasedAssets                    Float?
  c9_downstreamTransportationAndDistribution Float?
  c10_processingOfSoldProducts               Float?
  c11_useOfSoldProducts                      Float?
  c12_endOfLifeTreatmentOfSoldProducts       Float?
  c13_downstreamLeasedAssets                 Float?
  c14_franchises                             Float?
  c15_investments                            Float?
  /// Category 16 "Other" is not included in the GHG protocol
  /// but we use it to handle companies who don't report scope 3 categories according to the GHG protocol.
  c16_other                                  Float?

  metadataId  Int @map("sourceId")
  emissionsId Int @unique

  emissions Emissions @relation(fields: [emissionsId], references: [id])
  metadata  Metadata  @relation(fields: [metadataId], references: [id])
}

model Economy {
  id                Int    @id @default(autoincrement())
  turnover          Float
  unit              String
  employees         Int
  metadataId        Int
  reportingPeriodId Int    @unique

  reportingPeriod ReportingPeriod @relation(fields: [reportingPeriodId], references: [id])
  metadata        Metadata        @relation(fields: [metadataId], references: [id])
}

model Goal {
  id                Int     @id @default(autoincrement())
  description       String
  year              String?
  target            Float?
  // TODO: Maybe reference ReportingPeriod instead
  // However, baseYears for goals might be different than other reporting periods for the company.
  // Thus, we in some cases need to reference something else than the reporting periods
  // For now, let's store them as strings, but in the future maybe use another representation.
  baseYear          String
  metadataId        Int
  companyId         String
  reportingPeriodId Int?

  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  company         Company          @relation(fields: [companyId], references: [wikidataId])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

model Initiative {
  id                Int     @id @default(autoincrement())
  title             String
  description       String
  year              String?
  scope             String
  companyId         String
  metadataId        Int
  reportingPeriodId Int?

  company         Company          @relation(fields: [companyId], references: [wikidataId])
  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

/// Every updated data point also has associated metadata about who changed it, when, and using what source
model Metadata {
  id          Int      @id @default(autoincrement())
  comment     String?
  lastUpdated DateTime @default(now()) @updatedAt
  userId      Int
  sourceId    Int

  source          Source            @relation(fields: [sourceId], references: [id])
  goal            Goal[]
  initiative      Initiative[]
  economy         Economy[]
  scope1          Scope1[]
  scope2          Scope2[]
  scope3          Scope3[]
  reportingPeriod ReportingPeriod[]
  baseYear        BaseYear[]

  @@map("metadata")
}

/// The source defines where a data point comes from, and can be re-used for
/// multiple data points, for example linking the same report
/// which allows updating the report URL in one place if it changes.
model Source {
  id      Int     @id @unique @default(autoincrement())
  url     String?
  /// The comment can be used to specify another source than a report URL
  comment String?

  // The same source can be used for metadata about multiple datapoints
  metadata Metadata[]
}

// TODO: define this properly
// model User {
//   id  Int @id @default(autoincrement())
// }
