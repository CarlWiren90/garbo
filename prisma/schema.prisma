datasource db {
  provider = "sqlite"
  url      = "file:./db.db"
}

generator zod {
  provider = "prisma-zod-generator"
}

generator client {
  provider = "prisma-client-js"
}

model Company {
  /// wikidataId is our unique identifier to link to companies, also used to export to or import from wikidata
  wikidataId       String  @id
  name             String  @unique
  description      String?
  /// Company website URL
  url              String?
  // IDEA: This needs metadata so we can distinguish between AI generated industry gics and human verified data.
  industryGicsCode String?

  /// TODO: Save Swedish org number, which might be the same as LEI or ISIN
  // swedishOrgNumber

  // TODO: save country and city/region for each company

  // IDEA: tags: make it possible to categorise the data - e.g. "MVP", "batch 1" to enable further comparisons

  industryGics     IndustryGics?     @relation(fields: [industryGicsCode], references: [subIndustryCode])
  reportingPeriods ReportingPeriod[]
  goals            Goal[]
  initiatives      Initiative[]
  baseYears        BaseYear[]
}

// TODO: Maybe remove the BaseYear table, and instead keep references to specific base years directly on the company
// for example: baseYearScope1/2/3
// Then we could make use of the startDate and endDate, and align it with reporting periods
model BaseYear {
  id         Int    @id @default(autoincrement())
  // IDEA: maybe the year here should be in relation to a specific reporting period, since we need to account for special cases where reporting periods are not just one year
  year       Int
  scope      Int // 1-3
  companyId  String
  metadataId Int

  metadata Metadata @relation(fields: [metadataId], references: [id])
  company  Company  @relation(fields: [companyId], references: [wikidataId])
}

/// A table containing the standardised GICS codes for categorizing companies into various industries.
// TODO: Add IndustryGics to DB seeding script
model IndustryGics {
  sectorCode      String
  groupCode       String
  industryCode    String
  subIndustryCode String @id

  companies Company[]
}

/// A reporting period is a timespan for accounting emissions as well as financial data
model ReportingPeriod {
  id        Int      @id @default(autoincrement())
  startDate DateTime
  endDate   DateTime

  companyId   String
  emissionsId Int?
  metadataId  Int

  initiatives Initiative[]
  goals       Goal[]
  metadata    Metadata     @relation(fields: [metadataId], references: [id])
  economy     Economy?
  emissions   Emissions?
  company     Company      @relation(fields: [companyId], references: [wikidataId])
}

/// Reported emissions for a specific reporting period
model Emissions {
  id                     Int  @id @default(autoincrement())
  reportingPeriodId      Int  @unique
  scope1Id               Int  @unique
  scope2Id               Int  @unique
  scope3Id               Int  @unique
  biogenicEmissionsId    Int? @unique
  scope1And2Id           Int? @unique
  statedTotalEmissionsId Int? @unique

  // TODO: add calculated field `total` which combines scope 1 + 2 + 3.
  // This should be be calculated during runtime and returned as part of the API data.
  // The computed total could be used to compare against the statedTotal provided by the company report
  // In cases where we find discrepancies between the statedTotalEmissions and the actual total emissions, we should highlight this in the UI.
  statedTotalEmissions StatedTotalEmissions?
  scope1And2           Scope1And2?
  biogenicEmissions    BiogenicEmissions?
  reportingPeriod      ReportingPeriod       @relation(fields: [reportingPeriodId], references: [id])
  scope1               Scope1                @relation(fields: [scope1Id], references: [id])
  scope2               Scope2                @relation(fields: [scope2Id], references: [id])
  scope3               Scope3                @relation(fields: [scope3Id], references: [id])
}

/// This is used when companies only report a total number for either overall- or scope 3 emissions.
model StatedTotalEmissions {
  id    Int    @id @default(autoincrement())
  total Float
  unit  String

  emissionsId Int @unique
  metadataId  Int
  scope3Id    Int @unique

  emissions Emissions @relation(fields: [emissionsId], references: [id])
  metadata  Metadata  @relation(fields: [metadataId], references: [id])
  scope3    Scope3    @relation(fields: [scope3Id], references: [id])
}

/// This is used when companies have bad reporting where they have combined scope 1+2 as one value
model Scope1And2 {
  id          Int    @id @default(autoincrement())
  total       Float
  // TODO: reference the shared unit instead - for all instances
  unit        String
  emissionsId Int    @unique
  metadataId  Int

  emissions Emissions @relation(fields: [emissionsId], references: [id])
  metadata  Metadata  @relation(fields: [metadataId], references: [id])
}

/// Biogenic emissions are reported separately from scope 1-3
/// If we want to save a more detailed breakdown (when companies reported this), we can use the metadata comment to save this context
model BiogenicEmissions {
  id          Int    @id @default(autoincrement())
  /// Sometimes companies break it down into scope 1-3 - however these should always be stored as a total number according to the GHG protocol.
  total       Float
  unit        String
  metadataId  Int
  emissionsId Int    @unique

  metadata  Metadata  @relation(fields: [metadataId], references: [id])
  Emissions Emissions @relation(fields: [emissionsId], references: [id])
}

model Scope1 {
  id          Int    @id @default(autoincrement())
  total       Float?
  unit        String
  metadataId  Int
  emissionsId Int    @unique

  emissions Emissions?
  metadata  Metadata   @relation(fields: [metadataId], references: [id])
}

/// For scope 2 emissions, we choose either market-based, location-based or unknown (if the company didn't specify if mb or lb)
/// We generally prefer using market-based emissions, but if that doesn't exist we could use location-based ones, and finally unknown.
model Scope2 {
  id          Int    @id @default(autoincrement())
  unit        String
  /// Market-based emissions
  mb          Float?
  /// Location-based emissions
  lb          Float?
  /// Unknown scope 2 emissions could be either market-based or location-based
  unknown     Float?
  metadataId  Int
  emissionsId Int    @unique

  emissions Emissions?
  metadata  Metadata   @relation(fields: [metadataId], references: [id])
}

// IDEA: We need to separate scope3 into separate categories

// TODO: Maybe add stated total emissions for scope 3
// Should this be the same structure as emission totals, or specific for scope 3 totals

/// Scope 3 emissions according to the GHG protocol.
model Scope3 {
  id Int @id @default(autoincrement())

  /// Sometimes, companies only report a total value for scope 3 emissions without disclosing the scope 3 categories.
  /// Other times, they might report both, but their stated total scope 3 emissions might be different than the actual sum of their scope 3 categories.
  /// To get around this, we separate statedTotalEmissions from the actual mathematical total that we summarize during runtime.
  statedTotalEmissionsId Int?                  @unique
  statedTotalEmissions   StatedTotalEmissions?

  // TODO: use relation
  unit String

  // Scope 3 categories
  c1_purchasedGoods                          Float?
  c2_capitalGoods                            Float?
  c3_fuelAndEnergyRelatedActivities          Float?
  c4_upstreamTransportationAndDistribution   Float?
  c5_wasteGeneratedInOperations              Float?
  c6_businessTravel                          Float?
  c7_employeeCommuting                       Float?
  c8_upstreamLeasedAssets                    Float?
  c9_downstreamTransportationAndDistribution Float?
  c10_processingOfSoldProducts               Float?
  c11_useOfSoldProducts                      Float?
  c12_endOfLifeTreatmentOfSoldProducts       Float?
  c13_downstreamLeasedAssets                 Float?
  c14_franchises                             Float?
  c15_investments                            Float?
  /// "Other" is not included in the GHG protocol, but we use it to handle companies who invent their own scope 3 "categories".
  other                                      Float?

  metadataId  Int @map("sourceId")
  emissionsId Int @unique

  emissions Emissions?
  metadata  Metadata   @relation(fields: [metadataId], references: [id])
}

model Economy {
  id                Int    @id @default(autoincrement())
  turnover          Float
  unit              String
  employees         Int
  metadataId        Int
  reportingPeriodId Int    @unique

  reportingPeriod ReportingPeriod @relation(fields: [reportingPeriodId], references: [id])
  metadata        Metadata        @relation(fields: [metadataId], references: [id])
}

model Goal {
  id                Int     @id @default(autoincrement())
  description       String
  year              String?
  target            Float?
  // TODO: Maybe reference ReportingPeriod instead
  // However, baseYears for goals might be different than other reporting periods for the company.
  // Thus, we in some cases need to reference something else than the reporting periods
  // For now, let's store them as strings, but in the future maybe use another representation.
  baseYear          String
  metadataId        Int
  companyId         String
  reportingPeriodId Int?

  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  company         Company          @relation(fields: [companyId], references: [wikidataId])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

model Initiative {
  id                Int     @id @default(autoincrement())
  title             String
  description       String
  year              String?
  scope             String
  companyId         String
  metadataId        Int
  reportingPeriodId Int?

  company         Company          @relation(fields: [companyId], references: [wikidataId])
  metadata        Metadata         @relation(fields: [metadataId], references: [id])
  reportingPeriod ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id])
}

/// Every data point has associated metadata about who changed it, when, and using what source
model Metadata {
  id          Int      @id @default(autoincrement())
  /// The comment is used to add relevant information about why the datapoint looks like it does
  comment     String?
  lastUpdated DateTime @default(now()) @updatedAt
  userId      Int
  sourceId    Int

  // TODO: Maybe store multiple sources for each data point. Yes, this would be useful.
  // However, do we really need it? let's decide if we actually implement it

  source               Source                 @relation(fields: [sourceId], references: [id])
  goal                 Goal[]
  initiative           Initiative[]
  economy              Economy[]
  scope1               Scope1[]
  scope2               Scope2[]
  scope3               Scope3[]
  reportingPeriod      ReportingPeriod[]
  baseYear             BaseYear[]
  BiogenicEmissions    BiogenicEmissions[]
  Scope1And2           Scope1And2[]
  StatedTotalEmissions StatedTotalEmissions[]
  dataOrigin           DataOrigin?

  @@map("metadata")
}

// TODO: better name for status?
// TODO: add status - verified, AI extracted, estimated

// TODO: origin/method/kind/type might be better name 
// TODO: should we separate verified into a separate

/// Where the data originated from, e.g. manual entry, AI extraction or estimated with a tool like Exiobase.
model DataOrigin {
  id         Int    @id @default(autoincrement())
  name       String
  metadataId Int    @unique

  metadata Metadata @relation(fields: [metadataId], references: [id])
}

/// The source defines where a data point comes from, and can be re-used for
/// multiple data points, for example linking the same report
/// which allows updating the report URL in one place if it changes.
model Source {
  id      Int     @id @unique @default(autoincrement())
  url     String?
  /// The comment can be used to specify another source than a report URL
  comment String?

  // The same source can be used for metadata about multiple datapoints
  metadata Metadata[]
}

// TODO: Add relations to all places
// TODO: Add common units to DB seeding script
model EmissionUnit {
  id   Int    @id @default(autoincrement())
  /// In general, a unit like "tCO2e"
  unit String
}

// TODO: define this properly
// model User {
//   id  Int @id @default(autoincrement())
// }
